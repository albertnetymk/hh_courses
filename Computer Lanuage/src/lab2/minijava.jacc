/* 

This is the jacc specification for a parser for MiniJava as described
in Appel's book.

The lexer is generated by JFlex

*/

%{
	import syntaxtree.*;
%}

%class			minijavaParser
%interface		minijavaTokens
%next              	nextToken()
%get               	lexer.token
%semantic Object : 	lexer.semanticValue


/* Terminals with their types */
%token <String>  ID 
%token <Integer>     INTEGER_LITERAL 
%token <String> '{' '(' '[' ']' ')' '}' ';' ',' '='  '<' '+' '-' '*' '.' '!'
%token <String> CLASS PUBLIC STATIC VOID MAIN 
%token <String> STRING EXTENDS RETURN INT BOOLEAN 
%token <String> IF ELSE WHILE SYSTEMOUTPRINTLN 
%token <String> LENGTH TRUE FALSE AND THIS NEW

/* Precedence and associativity of operators */
%left AND
%left UNEG
%left '<'
%left '+' '-' 
%left '*'
%left UMINUS
%left '!'
%nonassoc '.' '['



/* Non terminals and their types*/ 
%type <MainClass>	mainClass
%type <ClassDecl>	classDecl
%type <ClassDeclList>	classDeclList
%type <VarDecl>		varDecl
%type <VarDeclList>	varDeclList
%type <MethodDecl>	methodDecl
%type <MethodDeclList>	methodDeclList
%type <Type>		type
%type <Formal> 		formal
%type <FormalList> 	formalList formalremain formalcomma
%type <Exp>        	exp
%type <ExpList>		expList expListremain expListcomma
%type <Statement>	statement
%type <StatementList>	statementList
%type <Identifier>	id

/* start symbol */
%start goal


%%
/* Grammar rules with actions to generate an abstract syntax tree */
goal		: mainClass classDeclList			{ ast  = new Program($1,$2);}
		;

mainClass	: CLASS id '{' PUBLIC STATIC VOID MAIN 
			'(' STRING '[' ']' id ')' 
			'{' statement '}' '}'			{ $$ = new MainClass($2,$12,$15);}
		;
classDecl	: CLASS id EXTENDS id '{' varDeclList
			 methodDeclList '}'			{ $$ = new ClassDeclExtends($2,$4,$6,$7);}
		| CLASS id '{' varDeclList methodDeclList '}'	{ $$ = new ClassDeclSimple($2,$4,$5);}
		;
classDeclList	: classDeclList classDecl			{ $1.add($2); $$ = $1;}
		| 						{ $$ = new ClassDeclList(); } 
		;
varDecl		: type id ';'					{ $$ = new VarDecl($1,$2);}
		;
varDeclList	: varDeclList varDecl				{ $1.add($2); $$ = $1;}
		| 						{ $$ = new VarDeclList();}
		;

methodDecl	: PUBLIC type id '(' formalList ')' '{' 
			varDeclList statementList
			RETURN exp ';' '}'			{if($5==null) {FormalList tmp=new FormalList(); $$=new MethodDecl($2,$3,tmp,$8,$9,$11);}
                                                                        else  $$ = new MethodDecl($2,$3,$5,$8,$9,$11);}
		| PUBLIC type id '(' formalList ')' '{'
			varDeclList 
			RETURN exp ';' '}'			{ if($5==null) {FormalList tmp=new FormalList(); 
										$$=new MethodDecl($2,$3,tmp,$8,new StatementList(),$10);}
                                                                        else $$ = new MethodDecl($2,$3,$5,$8,new StatementList(),$10);}
		;
formal		: type id					{ $$ = new Formal($1,$2);}
		;
formalList	: formal formalcomma				{ if ($2!=null) {$$=$2;((FormalList)$$).add(0,$1);} 
									else {FormalList tmp = new FormalList();tmp.add($1);$$=tmp;}}
		|						{ $$ = null;}
		;
formalcomma	: ',' formalremain				{ $$ = $2;}
		|						{ $$ = null;}
		;
formalremain	: formalremain ',' formal			{ ((FormalList)$1).add($3); $$ = $1;}
		| formal					{ $$ = new FormalList(); ((FormalList)$$).add($1);}
		;
methodDeclList	: methodDeclList methodDecl			{ $1.add($2); $$ = $1;}
		| 						{ $$ = new MethodDeclList();} 
		;

type		: INT '[' ']'					{ $$ = new IntArrayType();}
		| BOOLEAN					{ $$ = new BooleanType();}
		| INT						{ $$ = new IntegerType();}
		| id						{ $$ = new IdentifierType($1.s);}
		;

statement	: '{' statementList '}'				{ $$ = new Block($2);}
		| IF '(' exp ')' statement ELSE statement	{ $$ = new If($3,$5,$7);}
		| WHILE '(' exp ')' statement			{ $$ = new While($3,$5);}
		| SYSTEMOUTPRINTLN '(' exp ')' ';'		{ $$ = new Print($3);}
		| id '=' exp ';'				{ $$ = new Assign($1,$3);}
		| id '[' exp ']' '=' exp ';'			{ $$ = new ArrayAssign($1,$3,$6);}
		;
statementList	: statementList statement 			{ $1.add($2); $$ = $1;}
		| statement 					{ $$ = new StatementList(); ((StatementList)$$).add($1);} 
		;

exp        	: '-' exp 		    			{ $$ = new Minus(new IntegerLiteral(0),$2); }
	        | exp '+' exp             			{ $$ = new Plus($1,$3); }
		| exp '-' exp             			{ $$ = new Minus($1,$3); }
		| exp '*' exp	     				{ $$ = new Times($1,$3);}
		| exp AND exp	     				{ $$ = new And($1,$3);}
		| exp '<' exp 	     				{ $$ = new LessThan($1,$3);}
		| exp '[' exp ']'	     			{ $$ = new ArrayLookup($1,$3);}
		| exp '.' LENGTH 	     			{ $$ = new ArrayLength($1);}
	   	| exp '.' id '('expList ')'	     		{if($5==null) {ExpList tmp=new ExpList(); $$=new Call($1,$3,tmp);}
                                                                        else $$ = new Call($1, $3, $5); } 
           	| INTEGER_LITERAL         			{ $$ = new IntegerLiteral($1.intValue()); }
	   	| TRUE 		     				{ $$ = new True();}
	   	| FALSE		     				{ $$ = new False();}
	   	| id			     			{ $$ = new IdentifierExp($1.s);}
	   	| THIS 		     				{ $$ = new This();}
	   	| NEW INT '[' exp ']'     			{ $$ = new NewArray($4);}
	   	| NEW id '(' ')'	     			{ $$ = new NewObject($2);}
	   	| '!' exp 			     		{ $$ = new Not($2);}
	   	| '(' exp ')'	     				{ $$ = $2;}
           	;

expList	   	: exp expListcomma				{ if ($1!=null) if($2==null){$$=new ExpList();((ExpList)$$).add($1);}
									else{$$=$2;((ExpList)$$).add(0,$1);} else $$=$1;}
	   	| 						{ $$ = null;}
	   	;
expListcomma	: ',' expListremain				{ $$ = $2;}
		|						{ $$ = null;}
		;
expListremain 	: expListremain ',' exp				{ $1.add($3); $$ = $1;}
	      	| exp						{ $$ = new ExpList(); ((ExpList)$$).add($1);}
	      	;

id	   	: ID 		     				{ $$ = new Identifier($1);}
	   	;




%%
/* code in the parser class*/

private minijavaLexer lexer;
public  Program       ast;


/* constructor registering a lexer for minijava */
minijavaParser(minijavaLexer lexer){this.lexer=lexer;}

/* implementation of the nextToken() using lexer.yylex() that throws an
exception 
*/

private int nextToken(){
      try{ 
          return lexer.yylex();
       }catch(java.io.IOException e){System.out.println("IO exception from lexer!");e.printStackTrace();}
       return 0;
}	


private void yyerror(String msg) { 
    System.out.println(
      "ERROR "+ msg + "\n" +
      " at line   " +(lexer.line() + 1) + "\n" + 
      " at column " +(lexer.column() + 1) + "\n" + 
      " with token <<" + lexer.semanticValue + ">>"); }


